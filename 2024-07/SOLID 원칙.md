# 1.  단일 책임 원칙: **클래스가 하나의 책임이나 기능만을 가진다**

- 실제적인 비즈니스 로직을 가진 클래스와 그 클래스를 호출하는 클래스를 분리
- 애매하게 공통으로 묶는다 = 의존한다 ⇒ 애매하면 중복이 되더라도 분리하는 것이 좋다 (상황에 따라 다름)

<br><br>

# 2.  개방 폐쇄 원칙: 확장에는 열려있고, 수정에는 닫힘

- 새 기능을 추가할 때는 기존 모듈, 클래스, 함수를 수정하지 않고 기존 코드를 기반으로 새 코드를 추가하는 방식으로 코드를 확장해야 한다.
- 요구 가능성이 없는 사항들을 미리 준비하는 것은 과도한 설계 → 실제 필요할 때 리팩토링하는 게 나을 수 있음 (사바사)

<br><br>

# 3. 리스코프 치환 원칙: 상위 타입의 객체를 하위 타입의 객체로 치환해도 작동

- 자식 클래스는 부모 클래스가 선언한대로 기능이 동작함을 보장
- 입/출력, 예외 모두 부모 클래스를 따른다
- 부모 클래스의 지침을 모두 준수한다

⇒ 즉! 상속의 개념을 잘 지키라는 말이지.

<br>

- 자식 클래스는 부모 클래스의 기능을 확장시킨다.
- 두 클래스 간의 규약을 지킨다.

- **코드로 제어할 수 없다** ⇒ 계약, 지침이기 때문
    - delete 하라고 했을 때, 동일한 인터페이스만 가지고 있을 뿐이지 동일한 행위를 하는지는 개발자의 주관적인 판단이다.
    - 서로 다른 구현을 했는지는 컴파일러는 모른다. 개발자가 판단한다.
        - 코드의 의미적 올바름을 보장하지 않음

<br>

## Circle Ellipse Problem

원은 반지름이 같아야 하는데 다르게 정의함으로서 원의 정의를 깨트림

→ 컴파일러는 모름 개발자만 알 수 있음

![image](https://github.com/user-attachments/assets/826df4da-8111-404c-9407-f54d287cdf58)

<br>

## LSP와 다형성은 무엇이 다를까?
LSP: **상속** 관계에서 하위 클래스의 설계 방식을 설명하는 설계 원칙

다형성: 코드 구현 방식 (객체의 기능에 대한 설계를 추상적인 레벨에서 정의하고, **구현**을 따로 하는 것)

<br><br>

# 4. 인터페이스 분리 원칙: 자신이 사용하는 메서드에만 의존하라

- 하나의 일반적인 인터페이스 보다 여러 개의 구체적인 인터페이스가 낫다.
    - 불필요한 의존성을 가질 수 있기 때문

![image](https://github.com/user-attachments/assets/e5a3727b-1785-4bba-921e-6501a9272a99)


- Developer는 구현에 문제 없음
- Robot은 `eat()` 메서드 구현이 필요 없음
    - 불필요한 의존성
- 만약 Worker에 `takeBreak()` 를 추가한다면, Robot은 `takeBreak()`에 대해 구현을 강요 받음

<br><br>

# 5. 의존 역전 원칙: 고수준 모듈은 저수준 모듈의 구현에 의존하지 마라

- 고수준 = 의미 있는 단일 기능 제공 → 인터페이스
- 저수준 = 고수준 모듈의 기능 구현을 위해 필요한 하위 기능의 실제 구현

### 현실 세계

- 고수준 = 자동차는 속도가 높아지고 낮아진다
- 저수준 = 자동차의 엔진은 동력 생성을 담당해 자동차를 움직일 수 있게 한다

![image](https://github.com/user-attachments/assets/a4f030d5-fc67-4eda-a5ae-26dcf9339252)


![image](https://github.com/user-attachments/assets/6c1456a9-ed7c-433b-b3a2-e74f17c2bfca)


- 고수준이 저수준에 의존하게 되면 어떤 문제가 발생할까?
    - 유연성 부족
    - 확장성 문제
    - 유지보수의 어려움

![image](https://github.com/user-attachments/assets/d4068275-c90c-4813-a1ab-adc4a85a7361)
