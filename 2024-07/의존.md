# 의존을 다루려는 이유
개발자가 코드를 다루는 경우의 수
1. 기능 추가: 구조 변경
2. 버그 수정: 구조 변경 + 기능 변경
3. 리팩토링: 구조 변경 + 기능 변경
4. 최적화: 리소스 사용량 변경
=> 변경 대상 외에 다른 것은 변경되면 안 된다 = 의존

> 변경을 일으킬 때, **다른 것에 영향을 주지 않는다는 것**을 보장해야 한다.

<br><br>

# 의존이 야기하는 문제들
1. 변경의 어려움
2. 유지보수 비용 증가
3. 테스트 어려움
4. 재사용성 저하
5. 확장성 제한
6. 순환 의존성
7. 의존성 관리 어려움

> **약속과 규칙을 통한 의존 관리**
> - 레이어 관리
> - 적잘한 책임 분리
> - 테스트 코드 작성

<br><br>

# 의존을 관리하는 코드 설계
레이어드 아키텍처, 헥사고날 아키텍처, 클린 아키텍처 등 다양한 아키텍처가 있지만 다른 개발자들과 함께 개발할 때 모든 사람들이 해당 아키텍처에 동일하게 이해해야 하며, 추후에 내가 한 것을 개발하게 될 사람도 동일하게 이해해야 할 때 **학습 비용과 랜딩 비용**이 크게 발생한다.  
> **규칙이 지켜지는** 레이어드 아키텍처를 추천한다.

<br><br>

## 레이어드 아키텍처
- Controller > Service > Repository

![image](https://github.com/user-attachments/assets/eb8d3478-2c92-4e85-be40-b69a66a12fa6)

- Controller: 외부 인터페이스 정의
- Service: 비즈니스 로직 정의
- Repository: 데이터 접근

<br>

### 레이어드 아키텍처의 문제점
1. 책임이 불분명한 xxxService 지옥
2. 응집도가 떨어지는 의존으로 인한 테스트의 어려움
3. 순환 의존성

<br>

### 규칙
- API > UseCase > Implementaion > DataAccess

![image](https://github.com/user-attachments/assets/67dee2ec-db75-4e8e-a44d-00e2b6b0d5f3)


- 의존 방향은 아래로 흐른다 (역류 X)
- 의존 시 계층을 건너뛰지 않는다
- Entity는 Data Access 계층을 벗어나 UseCase와 Implementation에서 사용 가능
- **적절한 책임**
    - {도메인}{행동}UseCase

> 이러한 방식이 정석은 아님, 개인/팀이 정의하기 나름

<br>

### 예시
![image](https://github.com/user-attachments/assets/d485d2c5-11b8-4752-b366-86bf97da9d76)
특별한 문제가 없는 것처럼 보이지만 여러 기능이 한 데 모여 있음
- 이메일 유효성 검사
- 닉네임/비밀번호 유효성 검사
- User 객체 생성 및 저장
- 이메일 발송

<br>

#### 사용자 유효성 검사
![image](https://github.com/user-attachments/assets/021b8bc9-e312-4f73-a21b-b0952bfb342a)

#### 사용자 등록 서비스
![image](https://github.com/user-attachments/assets/66ea7c59-2c30-42e9-a7ed-b08e4d020116)

#### 이메일 서비스
![image](https://github.com/user-attachments/assets/28246144-a8bb-4187-b1e0-efd21645a967)

#### UserDTO
![image](https://github.com/user-attachments/assets/6a86c0dd-1ca3-4942-b195-6dab42986536)

책임을 적절하게 분리해 필요한 것만 의존하도록 한다.

> 테스트코드가 있으면, 코드 수정에 자신감이 붙을 수 있다.

<br><br>

# 멀티 모듈
> **모듈**
> - 프로그램을 구성하는 시스템을 독립적인 기능 단위로 분리한 형태
> - 원하는대로 합치고 쪼개는 관리의 용이성 제공

- 큰 프로젝트를 여러 개의 모듈로 나눠 관리하는 방식
- 모듈 간 의존성 관리가 매우 중요
- 멀티 모듈을 어떻게 구성하는지는 자유이므로 많은 의견이 나올 수 있음

#### 장점
- 복잡성을 낮춤
- 유지보수를 용이하게 함
- 재사용성을 높임
- 각 팀이 독립적으로 모듈 개발 가능

#### 단점
- 의존성 관리, 규칙
- 초기 설정

<br>

## 코드를 다루기 전에 생각할 것들
1. 변경의 대상이 무엇일까
2. 변경이 이루어졌는지 확인할 방법은 무엇일까
3. 다른 것에 영향을 주지 않았는지 확인할 방법은 무엇일까

<br>

## 좋은 테스트 루틴
- 빠른 실행 피드백
- 빠른 오류 위치 파악

<br>

### 통합 테스트의 단점
- 오류 위치 파악 어려움
    - 테스트 대상에서 멀어질수록 테스트 실패가 의미하는 바를 찾기 어렵다
> 통합 테스트 전에 작은 단위로 단위 테스트가 선행되면 좋다.

<br>

### 테스트 순서
1. 변경 대상 확인
    - 요구 사항을 소화하기 위해 코드 변경 대상 식별
2. 테스트 루틴 작성 위치 찾기
    - 코드 변경 대상이 변경됨에 따라 영향 받는 위치를 머릿속으로 생각하고 정리
    - 영향을 스케치해 시각화하는 것을 추천
        ![image](https://github.com/user-attachments/assets/2a2dcf78-9064-47dc-b887-ea490d32901e)

3. 테스트 루틴 작성
4. 변경 및 리팩토링 수행

<br>

> **테스트코드**
> 개발자들이 버그를 만들지 않도록 도움을 주는 환경을 구성할 수 있다.